# BOJ Silver

## 1260. DFS와 BFS - 실버 2

### DFS

DFS는 깊이 우선 탐색으로 시작 지점과 연결된 노드들을 끝까지 탐색 후 방문하지 않은 노드들을 확인 후 탐색하면서 돌아옴

예를 들어

            3
        1       5
      6   4    7  8

이러한 경우, 작은 수부터 탐색을 한다고 했으니

            3
        1       5
      4   6    7  8

이런 식으로 변할 것이며, 이는 방문여부를 확인하며 3 1 4 로 먼저 탐색을 함. 
그 후 1로 돌아와서 6이 탐색을 안했으므로 6을 탐색함.
그럼 현재 탐색한 순서는 3 1 4 6이 됨

그 후 3으로 돌아와서 5부분을 탐색하지 않았으므로 5 7 순으로 탐색하고, 7로 돌아온 후 탐색하지 않은 8을 탐색하며 끝이 남

즉, 결과적으로 탐색한 순서는 3 1 4 6 5 7 8 순이 된다. 이는 하나의 예시일 뿐

### BFS

BFS는 너비 우선 탐색으로 연결되어 있는 노드 먼저 다 탐색 후, 그 다음으로 이어져 나감
그래서 queue를 이용하여 담고, 

            3
        1       5
      4   6    7  8

이런 식이면 3을 초기값으로 queue에 담고 뺌. 

그리고 이 3과 연결된 부분을 탐색하며 q에 담음 -> 1 5 가 담기게 될 것

그 후 1이 젤 앞에 있으니 1을 pop 하고, 1과 연결되어 있는 부분을 q에 담음 5 6 4 가 q에 있을것

5를 pop 하고, 5와 연결된 부분을 q에 담음 6 4 7 8이 됨

4 pop, 4 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

6 pop, 6 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

7 pop, 7 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

8 pop, 8 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

이제 q 가 비었으니 탐색이 종료됨 -> 이러한 방식으로 너비 우선적으로 탐색하는 것이 BFS 이다.

결론적으로 BFS로 탐색한 순서는 3 1 5 4 6 7 8 순이 된다.

### 결론
DFS와 BFS에 대해서 알아보았다. DFS는 끝까지 이어진 순으로 쭉 들어갔다가 돌아오면서 탐색하지 않은 부분은 쭉 들어갔다가 나오는 방식으로
말그래도 깊이 우선 탐색을 시행하고,
BFS는 인접한 노드들을 먼저 확인을 하고 그 다음 깊이로 넘어가는 너비 우선탐색을 함을 알았다. 이 때 다음 탐색해야할 순서를 저장을 하기 위해 queue를 사용하여 도움이 되기도 함

간단한 개념을 이해하기 위한 문제였으며, 갈수록 심화될 것으로 판단

**소요시간 : 30분** => DFS와 BFS의 개념을 익히느라 오래걸림
---
## 2178. 미로 탐색 -> 실버 1

### BFS를 이용

문제를 파악을 하면, 시작 지점 (0,0)에서 끝지점인 (N-1, M-1) 까지 이동거리를 찾는 것이다.

이동 가능한 길은 1로 주어지고 이동 불가능한 곳은 0으로 주어지고, 시작지점에서 도착지점까지 이동할 수 있는 경우만 입력으로 주어진다고 했음.

그렇기에 이동가능한 방향을 순회하며 이동하면서 확인하는 방식으로 진행하였으며, 범위에서 범어나는 경우도 패스, 이동했을 경우에 0인 경우도 패스를 하면서 진행을 함.

여기서 만약에 이동할 수 있는 길이면 이동을 하고, 그 값을 q에 넣어서 대기상태에 두고, visit 배열 대신에 이동한 거리도 함께 기록할 수 있도록 이전까지 이동해온 값에 +1을 해오는 방식으로 진행.

이런식으로 진행하게 되면 초기는 1이고, 한번 이동하면 +1 이 되면서 2가 되는 식으로 이동거리가 된다. 그리고 또한 값이 올라가서 1이 아니게 되었으니 이미 이동한 길이고, 중복으로 이동할 경우는 없게 된다.

이런식으로 모든 경우의 수를 순회하고, 끝까지 도달하면 q는 empty가 될 것이고, 도착지점의 값을 return을 해주면 도착지점까지 이동한 거리가 된다.

이러한 결과가 최소가 되는 이유는 먼저 도착한 값으로 1이 아닌 최단거리로 저장이 되므로, 이동할 수 없는 위치가 되어서 최단 거리가 저장이 되는 것이고, 그 외의 값으로 갱신이 안됨.

**소요시간 : 30분** => 구현 방식 고민하다가 오래걸림
---
## 2606. 바이러스 -> 실버 3

### BFS를 이용

매우 간단한 BFS 문제였다. 왜 실버 3 문제인지 알 것 같은 문제. 기본적인 BFS의 개념만 알고 있으면, 바로 BFS 함수를 작성해서 문제를 해결할 수 있는 문제.

즉, 1번 컴퓨터로 부터 탐색할 수 있는 모든 컴퓨터의 수를 찾는 것임. 

그렇기에 1번 컴퓨터를 시작으로 1과 연결된 부분을 하나씩 BFS로 check를 하며 중복되지 않도록 visit함수로 확인을 하고, cnt를 증가시키며 감염된 컴퓨터 탐색 가능

**소요시간 : 10분** => BFS의 개념을 이해하고 간단한 문제는 빨리 해결 가능
---
## 2667. 단지번호붙이기 -> 실버 1

### BFS를 이용

실버 1치고는 해결 방안만 떠올리면 BFS를 이용하여 쉽게 풀 수 있는 문제였음. 

그룹을 찾고, 그 그룹 내에서의 개수를 count를 하며 그 값을 cnt vector에 담아주고, 그것을 정렬하여 그 크기와 내용물을 작은 순대로 출력하면 됐었다.

**소요시간 : 30분** => 간단한 BFS를 사용하는 방식이지만, 그에 대한 개념을 찾는 것에 어려움을 겪음
---
## 1012. 유기농 배추 - 실버 2

### BFS를 이용

이것은 그룹을 찾는 문제, 모든 경우를 순회하며, 그룹의 개수를 count해주는 형식으로 하면 됐음.

즉, visited의 역할이 중요했던 문제라고 봄.

**소요시간 : 30분** => 푸는데 오래 걸렸는데 생각해보면 이렇게 오래걸릴 문제였나 싶음
---
## 1316. 그룹 단어 체커 -> 실버 5

### 반복문과 조건문을 이용한 구현

그룹 단어인지 아닌지를 확인하는 문제였음. 그룹 단어는 한번나왔던 단어가 연속은 괜찮고, 다 다른 알파벳으로 나온 경우가 그룹단어임

그룹 단어가 아닌 경우는 나왔던 단어가 연속이 아니라 다른 알파벳을 끼고 다시 나오게 되면 그룹 단어가 아님.

예를 들면, **aabbccdd**는 중복으로 나오는 단어들이 있지만, 다 연속적으로 붙어있어서 연속이 됨

하지만 **abcda**는 중복으로 나오는 **a**가 연속적으로 나오는 것이 아닌 다른 단어를 사이에 두고 끊어져서 나오기 때문에 그룹 단어가 아님

이런 경우를 보고, 그룹 단어의 개수를 찾는 문제이고, 이를 해결하기 위해 2중 for문으로 i = 0, j = i + 1의 범위로 글자의 길이만큼 순회하였고,

str[i] == str[j]로 나왔던 글자가 나왔지만, str[i] != str[j - 1]로 연속이 아닌 것을 확인을 하게 되면 check 를 0으로 하고 반복문을 탈출,

해당 조건을 만족하지 않으면 그룹 단어인 것이 되므로 check = 1을 그대로 가지고 반복문을 탈출, 그러면 그룹단어의 개수를 증가 시킴.

이러한 형식으로 구현을 함.

**소요시간 : 15분** => 어떨 때 조건을 만족하는 지만 떠올리면 쉽게 풀 수 있는 문제
---
## 10828. 스택 -> 실버 4

### 스택에 대한 문제

**스택**을 구현하는 문제임. c++에는 스택 라이브러리가 존재하기 때문에 스택을 사용해서 풀면 되는 것임.

스택은 기적으로 FILO 구조로, 먼저 삽입된 것이 제일 나중에 나오게 되고, 나중에 들어온 것이 제일 먼저 나오게 되는 구조임.

해당 구조를 기억하며 나중에 스택이 필요한 문제에서 적절히 사용하면 될 듯 함

**소요시간 : 5분** => 스택 라이브러리를 사용해서 바로 구현

