# BOJ Silver

## 1260. DFS와 BFS - 실버 2

### DFS

DFS는 깊이 우선 탐색으로 시작 지점과 연결된 노드들을 끝까지 탐색 후 방문하지 않은 노드들을 확인 후 탐색하면서 돌아옴

예를 들어

            3
        1       5
      6   4    7  8

이러한 경우, 작은 수부터 탐색을 한다고 했으니

            3
        1       5
      4   6    7  8

이런 식으로 변할 것이며, 이는 방문여부를 확인하며 3 1 4 로 먼저 탐색을 함. 
그 후 1로 돌아와서 6이 탐색을 안했으므로 6을 탐색함.
그럼 현재 탐색한 순서는 3 1 4 6이 됨

그 후 3으로 돌아와서 5부분을 탐색하지 않았으므로 5 7 순으로 탐색하고, 7로 돌아온 후 탐색하지 않은 8을 탐색하며 끝이 남

즉, 결과적으로 탐색한 순서는 3 1 4 6 5 7 8 순이 된다. 이는 하나의 예시일 뿐

### BFS

BFS는 너비 우선 탐색으로 연결되어 있는 노드 먼저 다 탐색 후, 그 다음으로 이어져 나감
그래서 queue를 이용하여 담고, 

            3
        1       5
      4   6    7  8

이런 식이면 3을 초기값으로 queue에 담고 뺌. 

그리고 이 3과 연결된 부분을 탐색하며 q에 담음 -> 1 5 가 담기게 될 것

그 후 1이 젤 앞에 있으니 1을 pop 하고, 1과 연결되어 있는 부분을 q에 담음 5 6 4 가 q에 있을것

5를 pop 하고, 5와 연결된 부분을 q에 담음 6 4 7 8이 됨

4 pop, 4 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

6 pop, 6 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

7 pop, 7 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

8 pop, 8 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

이제 q 가 비었으니 탐색이 종료됨 -> 이러한 방식으로 너비 우선적으로 탐색하는 것이 BFS 이다.

결론적으로 BFS로 탐색한 순서는 3 1 5 4 6 7 8 순이 된다.

### 결론
DFS와 BFS에 대해서 알아보았다. DFS는 끝까지 이어진 순으로 쭉 들어갔다가 돌아오면서 탐색하지 않은 부분은 쭉 들어갔다가 나오는 방식으로
말그래도 깊이 우선 탐색을 시행하고,
BFS는 인접한 노드들을 먼저 확인을 하고 그 다음 깊이로 넘어가는 너비 우선탐색을 함을 알았다. 이 때 다음 탐색해야할 순서를 저장을 하기 위해 queue를 사용하여 도움이 되기도 함

간단한 개념을 이해하기 위한 문제였으며, 갈수록 심화될 것으로 판단

**소요시간 : 30분** => DFS와 BFS의 개념을 익히느라 오래걸림
---
## 2178. 미로 탐색 -> 실버 1

### BFS를 이용

문제를 파악을 하면, 시작 지점 (0,0)에서 끝지점인 (N-1, M-1) 까지 이동거리를 찾는 것이다.

이동 가능한 길은 1로 주어지고 이동 불가능한 곳은 0으로 주어지고, 시작지점에서 도착지점까지 이동할 수 있는 경우만 입력으로 주어진다고 했음.

그렇기에 이동가능한 방향을 순회하며 이동하면서 확인하는 방식으로 진행하였으며, 범위에서 범어나는 경우도 패스, 이동했을 경우에 0인 경우도 패스를 하면서 진행을 함.

여기서 만약에 이동할 수 있는 길이면 이동을 하고, 그 값을 q에 넣어서 대기상태에 두고, visit 배열 대신에 이동한 거리도 함께 기록할 수 있도록 이전까지 이동해온 값에 +1을 해오는 방식으로 진행.

이런식으로 진행하게 되면 초기는 1이고, 한번 이동하면 +1 이 되면서 2가 되는 식으로 이동거리가 된다. 그리고 또한 값이 올라가서 1이 아니게 되었으니 이미 이동한 길이고, 중복으로 이동할 경우는 없게 된다.

이런식으로 모든 경우의 수를 순회하고, 끝까지 도달하면 q는 empty가 될 것이고, 도착지점의 값을 return을 해주면 도착지점까지 이동한 거리가 된다.

이러한 결과가 최소가 되는 이유는 먼저 도착한 값으로 1이 아닌 최단거리로 저장이 되므로, 이동할 수 없는 위치가 되어서 최단 거리가 저장이 되는 것이고, 그 외의 값으로 갱신이 안됨.

**소요시간 : 30분** => 구현 방식 고민하다가 오래걸림
---
## 2606. 바이러스 -> 실버 3

### BFS를 이용

매우 간단한 BFS 문제였다. 왜 실버 3 문제인지 알 것 같은 문제. 기본적인 BFS의 개념만 알고 있으면, 바로 BFS 함수를 작성해서 문제를 해결할 수 있는 문제.

즉, 1번 컴퓨터로 부터 탐색할 수 있는 모든 컴퓨터의 수를 찾는 것임. 

그렇기에 1번 컴퓨터를 시작으로 1과 연결된 부분을 하나씩 BFS로 check를 하며 중복되지 않도록 visit함수로 확인을 하고, cnt를 증가시키며 감염된 컴퓨터 탐색 가능

**소요시간 : 10분** => BFS의 개념을 이해하고 간단한 문제는 빨리 해결 가능
---
## 2667. 단지번호붙이기 -> 실버 1

### BFS를 이용

실버 1치고는 해결 방안만 떠올리면 BFS를 이용하여 쉽게 풀 수 있는 문제였음. 

그룹을 찾고, 그 그룹 내에서의 개수를 count를 하며 그 값을 cnt vector에 담아주고, 그것을 정렬하여 그 크기와 내용물을 작은 순대로 출력하면 됐었다.

**소요시간 : 30분** => 간단한 BFS를 사용하는 방식이지만, 그에 대한 개념을 찾는 것에 어려움을 겪음
---
## 1012. 유기농 배추 - 실버 2

### BFS를 이용

이것은 그룹을 찾는 문제, 모든 경우를 순회하며, 그룹의 개수를 count해주는 형식으로 하면 됐음.

즉, visited의 역할이 중요했던 문제라고 봄.

**소요시간 : 30분** => 푸는데 오래 걸렸는데 생각해보면 이렇게 오래걸릴 문제였나 싶음
---
## 1316. 그룹 단어 체커 -> 실버 5

### 반복문과 조건문을 이용한 구현

그룹 단어인지 아닌지를 확인하는 문제였음. 그룹 단어는 한번나왔던 단어가 연속은 괜찮고, 다 다른 알파벳으로 나온 경우가 그룹단어임

그룹 단어가 아닌 경우는 나왔던 단어가 연속이 아니라 다른 알파벳을 끼고 다시 나오게 되면 그룹 단어가 아님.

예를 들면, **aabbccdd**는 중복으로 나오는 단어들이 있지만, 다 연속적으로 붙어있어서 연속이 됨

하지만 **abcda**는 중복으로 나오는 **a**가 연속적으로 나오는 것이 아닌 다른 단어를 사이에 두고 끊어져서 나오기 때문에 그룹 단어가 아님

이런 경우를 보고, 그룹 단어의 개수를 찾는 문제이고, 이를 해결하기 위해 2중 for문으로 i = 0, j = i + 1의 범위로 글자의 길이만큼 순회하였고,

str[i] == str[j]로 나왔던 글자가 나왔지만, str[i] != str[j - 1]로 연속이 아닌 것을 확인을 하게 되면 check 를 0으로 하고 반복문을 탈출,

해당 조건을 만족하지 않으면 그룹 단어인 것이 되므로 check = 1을 그대로 가지고 반복문을 탈출, 그러면 그룹단어의 개수를 증가 시킴.

이러한 형식으로 구현을 함.

**소요시간 : 15분** => 어떨 때 조건을 만족하는 지만 떠올리면 쉽게 풀 수 있는 문제
---
## 10828. 스택 -> 실버 4

### 스택에 대한 문제

**스택**을 구현하는 문제임. c++에는 스택 라이브러리가 존재하기 때문에 스택을 사용해서 풀면 되는 것임.

스택은 기적으로 FILO 구조로, 먼저 삽입된 것이 제일 나중에 나오게 되고, 나중에 들어온 것이 제일 먼저 나오게 되는 구조임.

해당 구조를 기억하며 나중에 스택이 필요한 문제에서 적절히 사용하면 될 듯 함

**소요시간 : 5분** => 스택 라이브러리를 사용해서 바로 구현
---
## 25206. 너의 평점은 -> 실버 5

### 조건문의 사용

학점에 따른 점수표를 조건문을 통해 세워서 계산을 하고, 총합에 전공과목들의 학점을 나누면 됨.

이 때, 학점은 PASS일 경우 에는 계산에서 제외하니 PASS일 때에는 더했던 학점을 뺴주면 됨

**소요시간 : 3분** => SO EASY
---
## 2839. 설탕 배달 -> 실버 4

**DP**에 대해 잘 못하는 관계로, DP를 정복하기 위해 해당 알고리즘 분류의 쉬운 문제를 풀어보기로 결정

### **DP**란?

DP는 동적 계획법이라 하고, 이는 또 다시 동일한 문제를 풀 일이 없도록, 처음으로 한 번 풀었을 때 그 결과를 **배열** 같은 곳에 저장을 해두고, 동일한 문제를 만나면 배열에서 가져오는 식으로 해결하는 것임

구현 방식은 **재귀**를 이용해서 Top-Down 방식으로 구현이 가능하고, **반복문**을 이용해서 Bottom-Up 방식으로 구현이 가능함

### 그럼 이 문제의 DP를 이용한 풀이법?

우선 **Bottom-Up** 방식을 이용하여 구현함. 처음에 그리디를 떠올리긴 했지만, DP를 연습하기 위함이니 일단 참음

n키로를 3과 5를 나눠서 딱 나누어 떨어지게 최소개수로 가져가려함. 

초기화를 할 때 3과 5는 초기값이니 1을 설정(3또는 5를 가져가면 하나만 가져가기 때문) 

1 2 4 는 큰값을 넣어서, 개수 카운트 안되게함 (최소가 되면 안되니, n이 5000이 최대니 5555로 설정)

최소값이니 이미 저장된 값들을 이용하여 개수를 하나씩 늘려가면 된다. 그러다보면 5와 3만 뺴서 작은 값들의 개수를 늘려가다보면 그것이 5와 3의 최소 개수가 될것

하지만 지정한 5555 이상이 나오게 되면 그것은 3과 5만 가져간 것이 아니기 때문에 조건문을 이용하여 -1을 반환하도록 함

즉, sugar[1] = sugar[2] = sugar[4] = 5555 로 설정하고, sugar[3] = sugar[5] = 1로 설정을 함

만약 n이 3이라면 3 하나만 가져가게 되니 1을 출력, 4는 큰값이니 5555가 출력되어 -1을 출력할 것.

더 나아가 6이라면 sugar[i] = min(sugar[i-3], sugar[i-5]) + 1 이기에 sugar[3]과 sugar[1]의 최소를 찾으면 1과 5555중 1이기에 sugar[6] = 1 + 1이 되어서 2가 됨

이 때 3킬로그램 2개를 가져간 것이 최소가 되는 것이 맞기 때문에 타당한 점화식이고, 이미 이용한 값을 통해 계산하는 것이기 때문에 반복문을 이용한 Bottom-Up 방식 DP를 사용함을 알 수 있음.

### 결론

DP적 사고가 아직은 부족한 것 같음. 특히 제일 먼저 떠올리는 방식이 그리디방식으로 5로 나누어떨어지면 그대로 그 몫을 출력, 그렇지 않으면 3을 빼가며 5로 나누어떨어질때까지 뺴는 것이었음

여러가지 방식을 떠올릴 수 있다는 것은 좋지만, DP를 통해 구현을 하면 시간복잡도가 줄기 때문에 DP적 사고를 할 수 있도록 할 것

Top-Down 방식 또한 구현할 수 있게 해야됨

**소요시간 : 30분** => 실버 4지만 DP적 사고로 오래 걸림
---

