# BOJ Silver

## 1260. DFS와 BFS - 실버 2

### DFS

DFS는 깊이 우선 탐색으로 시작 지점과 연결된 노드들을 끝까지 탐색 후 방문하지 않은 노드들을 확인 후 탐색하면서 돌아옴

예를 들어

            3
        1       5
      6   4    7  8

이러한 경우, 작은 수부터 탐색을 한다고 했으니

            3
        1       5
      4   6    7  8

이런 식으로 변할 것이며, 이는 방문여부를 확인하며 3 1 4 로 먼저 탐색을 함. 
그 후 1로 돌아와서 6이 탐색을 안했으므로 6을 탐색함.
그럼 현재 탐색한 순서는 3 1 4 6이 됨

그 후 3으로 돌아와서 5부분을 탐색하지 않았으므로 5 7 순으로 탐색하고, 7로 돌아온 후 탐색하지 않은 8을 탐색하며 끝이 남

즉, 결과적으로 탐색한 순서는 3 1 4 6 5 7 8 순이 된다. 이는 하나의 예시일 뿐

### BFS

BFS는 너비 우선 탐색으로 연결되어 있는 노드 먼저 다 탐색 후, 그 다음으로 이어져 나감
그래서 queue를 이용하여 담고, 

            3
        1       5
      4   6    7  8

이런 식이면 3을 초기값으로 queue에 담고 뺌. 

그리고 이 3과 연결된 부분을 탐색하며 q에 담음 -> 1 5 가 담기게 될 것

그 후 1이 젤 앞에 있으니 1을 pop 하고, 1과 연결되어 있는 부분을 q에 담음 5 6 4 가 q에 있을것

5를 pop 하고, 5와 연결된 부분을 q에 담음 6 4 7 8이 됨

4 pop, 4 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

6 pop, 6 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

7 pop, 7 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

8 pop, 8 연결 부분 중 방문하지 않은 거 없으니 담지 않고 pass

이제 q 가 비었으니 탐색이 종료됨 -> 이러한 방식으로 너비 우선적으로 탐색하는 것이 BFS 이다.

결론적으로 BFS로 탐색한 순서는 3 1 5 4 6 7 8 순이 된다.

### 결론
DFS와 BFS에 대해서 알아보았다. DFS는 끝까지 이어진 순으로 쭉 들어갔다가 돌아오면서 탐색하지 않은 부분은 쭉 들어갔다가 나오는 방식으로
말그래도 깊이 우선 탐색을 시행하고,
BFS는 인접한 노드들을 먼저 확인을 하고 그 다음 깊이로 넘어가는 너비 우선탐색을 함을 알았다. 이 때 다음 탐색해야할 순서를 저장을 하기 위해 queue를 사용하여 도움이 되기도 함

간단한 개념을 이해하기 위한 문제였으며, 갈수록 심화될 것으로 판단

**소요시간 : 30분** => DFS와 BFS의 개념을 익히느라 오래걸림
---
## 2178. 미로 탐색 -> 실버 1

### BFS를 이용

문제를 파악을 하면, 시작 지점 (0,0)에서 끝지점인 (N-1, M-1) 까지 이동거리를 찾는 것이다.

이동 가능한 길은 1로 주어지고 이동 불가능한 곳은 0으로 주어지고, 시작지점에서 도착지점까지 이동할 수 있는 경우만 입력으로 주어진다고 했음.

그렇기에 이동가능한 방향을 순회하며 이동하면서 확인하는 방식으로 진행하였으며, 범위에서 범어나는 경우도 패스, 이동했을 경우에 0인 경우도 패스를 하면서 진행을 함.

여기서 만약에 이동할 수 있는 길이면 이동을 하고, 그 값을 q에 넣어서 대기상태에 두고, visit 배열 대신에 이동한 거리도 함께 기록할 수 있도록 이전까지 이동해온 값에 +1을 해오는 방식으로 진행.

이런식으로 진행하게 되면 초기는 1이고, 한번 이동하면 +1 이 되면서 2가 되는 식으로 이동거리가 된다. 그리고 또한 값이 올라가서 1이 아니게 되었으니 이미 이동한 길이고, 중복으로 이동할 경우는 없게 된다.

이런식으로 모든 경우의 수를 순회하고, 끝까지 도달하면 q는 empty가 될 것이고, 도착지점의 값을 return을 해주면 도착지점까지 이동한 거리가 된다.

이러한 결과가 최소가 되는 이유는 먼저 도착한 값으로 1이 아닌 최단거리로 저장이 되므로, 이동할 수 없는 위치가 되어서 최단 거리가 저장이 되는 것이고, 그 외의 값으로 갱신이 안됨.

**소요시간 : 30분** => 구현 방식 고민하다가 오래걸림
---
## 2606. 바이러스 -> 실버 3

### BFS를 이용

매우 간단한 BFS 문제였다. 왜 실버 3 문제인지 알 것 같은 문제. 기본적인 BFS의 개념만 알고 있으면, 바로 BFS 함수를 작성해서 문제를 해결할 수 있는 문제.

즉, 1번 컴퓨터로 부터 탐색할 수 있는 모든 컴퓨터의 수를 찾는 것임. 

그렇기에 1번 컴퓨터를 시작으로 1과 연결된 부분을 하나씩 BFS로 check를 하며 중복되지 않도록 visit함수로 확인을 하고, cnt를 증가시키며 감염된 컴퓨터 탐색 가능

**소요시간 : 10분** => BFS의 개념을 이해하고 간단한 문제는 빨리 해결 가능
---
## 2667. 단지번호붙이기 -> 실버 1

### BFS를 이용

실버 1치고는 해결 방안만 떠올리면 BFS를 이용하여 쉽게 풀 수 있는 문제였음. 

그룹을 찾고, 그 그룹 내에서의 개수를 count를 하며 그 값을 cnt vector에 담아주고, 그것을 정렬하여 그 크기와 내용물을 작은 순대로 출력하면 됐었다.

**소요시간 : 30분** => 간단한 BFS를 사용하는 방식이지만, 그에 대한 개념을 찾는 것에 어려움을 겪음
---
## 1012. 유기농 배추 - 실버 2

### BFS를 이용

이것은 그룹을 찾는 문제, 모든 경우를 순회하며, 그룹의 개수를 count해주는 형식으로 하면 됐음.

즉, visited의 역할이 중요했던 문제라고 봄.

**소요시간 : 30분** => 푸는데 오래 걸렸는데 생각해보면 이렇게 오래걸릴 문제였나 싶음
---

